"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Transaction = void 0;
const Signer_1 = require("./Signer");
class Transaction {
    constructor(c) {
        var _a, _b, _c, _d, _e;
        this.signer = c === null || c === void 0 ? void 0 : c.signer;
        this.provider = c === null || c === void 0 ? void 0 : c.provider;
        this.options = {
            broadcast: true,
            sendAbis: true,
            ...c === null || c === void 0 ? void 0 : c.options,
        };
        this.transaction = {
            header: {
                ...(((_a = c === null || c === void 0 ? void 0 : c.options) === null || _a === void 0 ? void 0 : _a.chainId) && { chain_id: c.options.chainId }),
                ...(((_b = c === null || c === void 0 ? void 0 : c.options) === null || _b === void 0 ? void 0 : _b.rcLimit) && { rc_limit: c.options.rcLimit }),
                ...(((_c = c === null || c === void 0 ? void 0 : c.options) === null || _c === void 0 ? void 0 : _c.nonce) && { nonce: c.options.nonce }),
                ...(((_d = c === null || c === void 0 ? void 0 : c.options) === null || _d === void 0 ? void 0 : _d.payer) && { payer: c.options.payer }),
                ...(((_e = c === null || c === void 0 ? void 0 : c.options) === null || _e === void 0 ? void 0 : _e.payee) && { payee: c.options.payee }),
            },
            operations: [],
        };
    }
    /**
     * Function to push an operation to the transaction. It can be created
     * in several ways. Example:
     *
     * @example
     * ```ts
     * const koin = new Contract({
     *   id: "19JntSm8pSNETT9aHTwAUHC5RMoaSmgZPJ",
     *   abi: utils.tokenAbi,
     * }).functions;
     * const signer = Signer.fromSeed("my seed");
     * const provider = new Provider(["https://api.koinos.io"]);
     * signer.provider = provider;
     * const tx = new Transaction({ signer });
     *
     * // method 1
     * await tx.pushOperation(koin.transfer, {
     *   from: "1NRYHBYr9qxYQAeVqfdSvyjJemRQ4qD3Mt",
     *   to: "13UdKjYuzfBYbB6bGLQkUN9DJRFPCmG1mU",
     *   value: "1000",
     * });
     *
     * // method 2
     * await tx.pushOperation(
     *   koin.transfer({
     *     from: "1NRYHBYr9qxYQAeVqfdSvyjJemRQ4qD3Mt",
     *     to: "13UdKjYuzfBYbB6bGLQkUN9DJRFPCmG1mU",
     *     value: "1000",
     *   },{
     *    onlyOperation: true,
     *   })
     * );
     *
     * // method 3
     * await tx.pushOperation(
     *   await koin.transfer({
     *     from: "1NRYHBYr9qxYQAeVqfdSvyjJemRQ4qD3Mt",
     *     to: "13UdKjYuzfBYbB6bGLQkUN9DJRFPCmG1mU",
     *     value: "1000",
     *   },{
     *    onlyOperation: true,
     *   })
     * );
     *
     * // method 4
     * const { operation } = await koin.transfer({
     *   from: "1NRYHBYr9qxYQAeVqfdSvyjJemRQ4qD3Mt",
     *   to: "13UdKjYuzfBYbB6bGLQkUN9DJRFPCmG1mU",
     *   value: "1000",
     * },{
     *  onlyOperation: true,
     * });
     * await tx.pushOperation(operation)
     * ```
     *
     */
    async pushOperation(input, args) {
        let operation;
        if (typeof input === "function") {
            const result = await input(args, { onlyOperation: true });
            operation = result.operation;
        }
        else {
            let inp;
            if (input instanceof Promise) {
                inp = await input;
            }
            else {
                inp = input;
            }
            if (inp.operation) {
                operation = inp.operation;
            }
            else {
                operation = input;
            }
        }
        if (!this.transaction.operations)
            this.transaction.operations = [];
        this.transaction.operations.push(operation);
    }
    /**
     * Functon to prepare the transaction (set headers, merkle
     * root, etc)
     */
    async prepare(options) {
        if (options) {
            const header = {
                ...((options === null || options === void 0 ? void 0 : options.chainId) && { chain_id: options.chainId }),
                ...((options === null || options === void 0 ? void 0 : options.rcLimit) && { rc_limit: options.rcLimit }),
                ...((options === null || options === void 0 ? void 0 : options.nonce) && { nonce: options.nonce }),
                ...((options === null || options === void 0 ? void 0 : options.payer) && { payer: options.payer }),
                ...((options === null || options === void 0 ? void 0 : options.payee) && { payee: options.payee }),
            };
            this.transaction.header = {
                ...this.transaction.header,
                ...header,
            };
        }
        if (this.signer) {
            this.transaction = await this.signer.prepareTransaction(this.transaction);
        }
        else {
            if (!this.transaction.header || !this.transaction.header.payer) {
                throw new Error("no payer defined");
            }
            const signer = Signer_1.Signer.fromSeed("0");
            signer.provider = this.provider;
            this.transaction = await signer.prepareTransaction(this.transaction);
        }
        return this.transaction;
    }
    /**
     * Function to sign the transaction
     */
    async sign(abis) {
        if (!this.signer)
            throw new Error("no signer defined");
        if (!this.transaction.id)
            await this.prepare();
        return this.signer.signTransaction(this.transaction, this.options.sendAbis ? abis : undefined);
    }
    /**
     * Function to broadcast the transaction
     */
    async send(options) {
        const opts = {
            ...this.options,
            ...options,
        };
        if (!this.transaction.id)
            await this.prepare();
        if (this.signer && this.signer.provider) {
            const { transaction: tx, receipt } = await this.signer.sendTransaction(this.transaction, opts);
            this.transaction = tx;
            this.waitFunction = tx.wait;
            return receipt;
        }
        if (!this.provider)
            throw new Error("provider not defined");
        if (!this.transaction.signatures || !this.transaction.signatures.length) {
            throw new Error("transaction without signatures and no signer defined");
        }
        if (opts.beforeSend) {
            await opts.beforeSend(this.transaction, opts);
        }
        const { transaction: tx, receipt } = await this.provider.sendTransaction(this.transaction, opts.broadcast);
        this.transaction = tx;
        this.waitFunction = tx.wait;
        return receipt;
    }
    async wait(type, timeout) {
        if (!this.waitFunction)
            throw new Error("no wait function defined");
        return this.waitFunction(type, timeout);
    }
}
exports.Transaction = Transaction;
//# sourceMappingURL=Transaction.js.map